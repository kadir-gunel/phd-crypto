#include<stdlib.h>
#include<iostream>
#include<string.h>
#include<stdio.h>
#include<boost/predef.h>
#include<ctime>
#include<fstream>
#include<openssl/sha.h>

#include "Network.hpp"
#include <math.h>
#include <boost/numeric/ublas/io.hpp>

#include <typeinfo>

using std::cin;
using std::cout;
using std::stol;
using std::string;
using std::to_string;
using std::int_fast64_t;


string returnDiskID(string cmd) {
  string diskID;
  FILE * stream;
  const int max_buffer = 256;
  char buffer[max_buffer];
  cmd.append(" 2>&1");

  stream = popen(cmd.c_str(), "r");
  if (stream) {
    while (!feof(stream))
      if (fgets(buffer, max_buffer, stream) != NULL) diskID.append(buffer);
    pclose(stream);
  }
  return diskID;
}

string generateKey(string serial){
  unsigned char digest[SHA_DIGEST_LENGTH];
  char string[serial.size()+1];
  strcpy(string, serial.c_str());
  SHA1((unsigned char*)&string, strlen(string), (unsigned char*)&digest);    
  char mdString[SHA_DIGEST_LENGTH*2+1];
  for(int i = 0; i < SHA_DIGEST_LENGTH; i++)
    sprintf(&mdString[i*2], "%02x", (unsigned int)digest[i]);
 
  return mdString;
  
}


bool checkLicenseKey(string key, string cmd){
  std::string serial = generateKey(returnDiskID(cmd));
  char serialArray[serial.size()+1];
  char keyArray[key.size()+1];

  std::ofstream license; //writing to file
  license.open("/Users/kg/Desktop/license.txt");
  license << key;
  license.close();

  strcpy(serialArray, serial.c_str());
  strcpy(keyArray, key.c_str());
  for(int i = 0; i < key.size() ; i++){
    if(keyArray[i] != serialArray[i])
      return false;
  }
  return true;
}

void activation(string userKey, string cmd){
  if(checkLicenseKey(userKey, cmd)){
     std::cout << "Activation done!" << std::endl;
  }
  else{
     std::cout << "Please Contact with S.W. Company" << std::endl;
     std::cout << "Exiting..." << std::endl;
     std::exit(0);
  }
}

int main()
{
  std::string userKey; // generated by the company
  std::string cmd; 
  std::ifstream fin("/Users/kg/Desktop/license.txt"); // for reading from file
  
  if(!fin.good()){ // for the first time ; if the license.txt does not exist.
    std::cout << "Welcome, Please Enter Your License Key : "; // for instance 2891256592766187
    std::cin >> userKey;
    std::cout << std::endl;
    
    // for mac os
    if(BOOST_OS_MACOS){
      cmd = "ioreg -rd1 -w0 -c AppleAHCIDiskDriver | grep Serial | sed -n 1p | grep -Eo '[0-9]+'";
      activation(userKey, cmd);
      std::string cont;
      std::cout << "Do you want to continue to execution ? (Y/N) "; // for instance 2891256592766187
      std::cin >> cont;
      if(cont == "N"){
	return 0;
      }
    }
    // for linux
    else if(BOOST_OS_LINUX){
      cmd = returnDiskID("udevadm info --query=all --name=/dev/sda | grep ID_SERIAL_SHORT");
      activation(userKey, cmd);
    }
    // for other os
    else {
      std::cout << "NON SUPPORTED PLATFORM - POSSIBLY A WINDOWS MACHINE!" << std::endl;
      return 0;
    }
  }
  else { // license is generated hence there exist the license.txt
    std::string license;
    if (fin.is_open()){
      getline(fin,license);
      fin.close();
    }
    //else cout << "Unable to open file";
      if(BOOST_OS_MACOS){
	cmd = "ioreg -rd1 -w0 -c AppleAHCIDiskDriver | grep Serial | sed -n 1p | grep -Eo '[0-9]+'";
	activation(license, cmd);
      }

      else if(BOOST_OS_LINUX){
	cmd = returnDiskID("udevadm info --query=all --name=/dev/sda | grep ID_SERIAL_SHORT");
	activation(userKey, cmd);
      }
      /*FLOW OF COMPUTATION IF LICENCE KEY PASSES*/
      std::cout << "Execution Started" << std::endl;
      std::vector<int> layers;
      layers.push_back(1);
      layers.push_back(2);
      layers.push_back(1);
      
      Network net(layers, 0.001);
      std::cout << net << std::endl;
    
      /* Training */
      matrix<double>	X(200,1), Y(200,1);
      for (int i=-100; i < 100; i += 1){
	X(i+100, 0) = i / 100.0;
	Y(i+100, 0) = pow(i, 2) / 1000.0;
      }
      net.fit(X, Y, 10000);
      /* Predict */
      vector<double> res(200);
      for (double i=-100; i < 100; ++i){
	vector<double> a(1);
	a[0] = i / 100;
	res.insert_element(i + 100, (*(net.predict(a)))[0] * 1000.0);
      }
      std::cout << res << std::endl;
      return 0;
  }
}
